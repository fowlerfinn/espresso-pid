/*
  Initial release:  02/21/2019
  updated: 06/04/2019 (relay output)
  Author: Matt FowlerFinn
  Platforms: WEMOS D1 lite & W
  ------------------------------------------------------------------------
  Description: 
  espresso pid

  Sensor:
  ds18b20 on i2c bus
  ------------------------------------------------------------------------
  License:
  Released under the MIT license. Please check LICENSE.txt for more
  information.  All text above must be included in any redistribution. 
*/

/*TODO:
 * remove adafruit(now broken w/ remapped i2c), port to u8g2
 * add gaggia logo on startup
 * add status display
 */
#include <Arduino.h>
#include <U8g2lib.h>

#include <OneWire.h>
#include <DallasTemperature.h>
#include <PID_v1.h>
#include <Wire.h>


#if (ESP32)  // --HELTEC WIFI 32 (ESP32)-- 
  #warning "compiling for HELTEC WIFI 32 (ESP32)"
  //static const uint8_t Vext = 21;
  //static const uint8_t LED  = 25;
  U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ 16, /* clock=*/ 15, /* data=*/ 4);   // ESP32 Thing, HW I2C with pin remapping & full buffer
  #define SSRPin 14 
  #define ONE_WIRE_BUS 27

#else // --WEMOS D1 Lite (ESP8266)-- 
  #warning "compiling for WEMOS D1 Lite (ESP8266)"
  #define SSRPin D2 
  #define ONE_WIRE_BUS D1
  int OLED_RESET = 16;
  #define DISPLAY_WIDTH 128 // OLED display width, in pixels
  #define DISPLAY_HEIGHT 64 // OLED display height, in pixels  
  static const uint8_t SCL_OLED = SCL;
  static const uint8_t SDA_OLED = SDA;
  
#endif
//both boards can use LED_BUILTIN

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);
DeviceAddress insideThermometer;

#define SERIAL_BAUD 115200


double Setpoint = 103; //99c-107c for 95c at grouphead
int toleranceWindow = 2; // +/- degrees for acceptable operation feedback 
double aggKp=100, aggKi=0, aggKd=0;
double Kp=10, Ki=.5, Kd=95; //was 30,10,90

float celsius;
double Input, Output;

PID myPID(&Input, &Output, &Setpoint, aggKp, aggKi, aggKd, DIRECT);

//freq to run pid and switch on/off the heater AND OUTPUT SCALE
int WindowSize = 1000; //in microseconds
int pidMaxValue = 100;
unsigned long windowStartTime;

bool tempReady;


#define Gaggia_width 128
#define Gaggia_height 39
static unsigned char Gaggia_bits[] PROGMEM = {
   0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x3c,
   0x00, 0x00, 0x0e, 0xc0, 0x03, 0x00, 0x1c, 0x00, 0x00, 0xfc, 0x00, 0x00,
   0x1e, 0x00, 0x00, 0x3e, 0x00, 0x80, 0x0f, 0xc0, 0x03, 0x00, 0x1e, 0x00,
   0x00, 0xfe, 0x00, 0x00, 0x1e, 0x00, 0x80, 0x3f, 0x00, 0xc0, 0x0f, 0xc0,
   0x03, 0x00, 0x1e, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x1f, 0x00, 0xc0, 0x3f,
   0x00, 0xf0, 0x0f, 0xc0, 0x03, 0x00, 0x3e, 0x00, 0x80, 0x1f, 0x00, 0x00,
   0x1f, 0x00, 0xe0, 0x0f, 0x00, 0xf8, 0x03, 0xc0, 0x03, 0x00, 0x3e, 0x00,
   0xc0, 0x0f, 0x00, 0x00, 0x3f, 0x00, 0xf0, 0x03, 0x00, 0xf8, 0x01, 0xc0,
   0x03, 0x00, 0x3f, 0x00, 0xe0, 0x07, 0x00, 0x80, 0x3f, 0x00, 0xf8, 0x01,
   0x00, 0x7c, 0x00, 0xc0, 0x03, 0x00, 0x3f, 0x00, 0xe0, 0x03, 0x00, 0x80,
   0x3f, 0x00, 0xf8, 0x00, 0x00, 0x3e, 0x00, 0xc0, 0x03, 0x00, 0x7f, 0x00,
   0xf0, 0x01, 0x00, 0x80, 0x3f, 0x00, 0x7c, 0x00, 0x00, 0x1e, 0x00, 0xc0,
   0x03, 0x80, 0x7f, 0x00, 0xf0, 0x00, 0x00, 0x80, 0x7f, 0x00, 0x3c, 0x00,
   0x00, 0x1f, 0x00, 0xc0, 0x03, 0x80, 0x7f, 0x00, 0xf8, 0x00, 0x00, 0xc0,
   0x7f, 0x00, 0x3c, 0x00, 0x00, 0x0f, 0x00, 0xc0, 0x03, 0x80, 0x7f, 0x00,
   0x78, 0x00, 0x00, 0xc0, 0x7f, 0x00, 0x3e, 0x00, 0x00, 0x0f, 0x00, 0xc0,
   0x03, 0x80, 0xff, 0x00, 0x78, 0x00, 0x00, 0xc0, 0xfb, 0x00, 0x1e, 0x00,
   0x80, 0x0f, 0x00, 0xc0, 0x03, 0xc0, 0xf7, 0x00, 0x78, 0x00, 0x00, 0xc0,
   0xf3, 0x00, 0x1e, 0x00, 0x80, 0x07, 0x00, 0xc0, 0x03, 0xc0, 0xf3, 0x00,
   0x78, 0x00, 0x00, 0xe0, 0xf3, 0x00, 0x1e, 0x00, 0x80, 0x07, 0x00, 0xc0,
   0x03, 0xc0, 0xf3, 0x01, 0x78, 0x00, 0x00, 0xe0, 0xf1, 0x00, 0x1e, 0x00,
   0x80, 0x07, 0x00, 0xc0, 0x03, 0xc0, 0xe3, 0x01, 0x78, 0xc0, 0x03, 0xe0,
   0xf1, 0x01, 0x1e, 0xf0, 0x80, 0x07, 0x7c, 0xc0, 0x03, 0xe0, 0xe3, 0x01,
   0x78, 0xc0, 0x03, 0xf0, 0xe1, 0x01, 0x1e, 0xf0, 0x80, 0x07, 0x7c, 0xc0,
   0x03, 0xe0, 0xe1, 0x01, 0x78, 0xc0, 0x03, 0xf0, 0xe1, 0x01, 0x1e, 0xf0,
   0x80, 0x0f, 0x7c, 0xc0, 0x03, 0xe0, 0xe1, 0x03, 0x78, 0xc0, 0x03, 0xf0,
   0xe0, 0x01, 0x1e, 0xf0, 0x80, 0x0f, 0x7c, 0xc0, 0x03, 0xf0, 0xc1, 0x03,
   0x78, 0xc0, 0x03, 0xf0, 0xff, 0x03, 0x3e, 0xf0, 0x00, 0x0f, 0x7c, 0xc0,
   0x03, 0xf0, 0xff, 0x03, 0xf8, 0xc0, 0x03, 0xf8, 0xff, 0x03, 0x3c, 0xf0,
   0x00, 0x1f, 0x7c, 0xc0, 0x03, 0xf0, 0xff, 0x03, 0xf0, 0xc0, 0x03, 0xf8,
   0xff, 0x03, 0x7c, 0xf0, 0x00, 0x1f, 0x7c, 0xc0, 0x03, 0xf0, 0xff, 0x07,
   0xf0, 0xc1, 0x03, 0xf8, 0xff, 0x07, 0x78, 0xf0, 0x00, 0x3e, 0x7c, 0xc0,
   0x03, 0xf8, 0xff, 0x07, 0xe0, 0xc3, 0x03, 0x78, 0xc0, 0x07, 0xf8, 0xf0,
   0x00, 0x7e, 0x7c, 0xc0, 0x03, 0xf8, 0x80, 0x07, 0xe0, 0xc7, 0x03, 0x7c,
   0x80, 0x07, 0xf0, 0xf1, 0x00, 0xfc, 0x7c, 0xc0, 0x03, 0x78, 0x80, 0x0f,
   0xc0, 0xcf, 0x03, 0x3c, 0x80, 0x07, 0xf0, 0xf7, 0x00, 0xf8, 0x7d, 0xc0,
   0x03, 0x78, 0x00, 0x0f, 0x80, 0xff, 0x03, 0x3c, 0x80, 0x0f, 0xe0, 0xff,
   0x00, 0xf0, 0x7f, 0xc0, 0x03, 0x7c, 0x00, 0x0f, 0x00, 0xff, 0x03, 0x3c,
   0x00, 0x0f, 0xc0, 0xff, 0x00, 0xe0, 0x7f, 0xc0, 0x03, 0x3c, 0x00, 0x0f,
   0x00, 0xfe, 0x03, 0x3e, 0x00, 0x0f, 0x00, 0xff, 0x00, 0xc0, 0x7f, 0xc0,
   0x03, 0x3c, 0x00, 0x1f, 0x00, 0xf8, 0x03, 0x1e, 0x00, 0x0f, 0x00, 0xfe,
   0x00, 0x00, 0x7f, 0xc0, 0x03, 0x3e, 0x00, 0x1e, 0x00, 0xe0, 0x03, 0x1e,
   0x00, 0x1f, 0x00, 0xf8, 0x00, 0x00, 0x7e, 0xc0, 0x03, 0x3e, 0x00, 0x1e,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

void drawGaggia() {
  u8g2.drawXBMP(0,10,Gaggia_width,Gaggia_height,Gaggia_bits);
}

void setup()   {     
  tempReady = false;
  
  Serial.begin(SERIAL_BAUD);
  delay(1000);

  pinMode(SSRPin, OUTPUT);
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(SSRPin, LOW);
  digitalWrite(LED_BUILTIN, LOW);

  Serial.print("Locating devices...");
  sensors.begin();
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  Serial.print("Parasite power is: "); 
  if (sensors.isParasitePowerMode()) Serial.println("ON");
  else Serial.println("OFF");

  if (!sensors.getAddress(insideThermometer, 0)) Serial.println("Unable to find address for Device 0"); 
  Serial.print("Device 0 Address: ");
  printAddress(insideThermometer);
  Serial.println();
  // set the resolution to 12 bit (Each Dallas/Maxim device is capable of several different resolutions)
  sensors.setResolution(insideThermometer, 12);
 
  Serial.print("Device 0 Resolution: ");
  Serial.print(sensors.getResolution(insideThermometer), DEC); 
  Serial.println();

  myPID.SetTunings(aggKp, aggKi, aggKd);
  myPID.SetOutputLimits(0, pidMaxValue);
  windowStartTime = millis();
  myPID.SetMode(AUTOMATIC);
  
  u8g2.begin();
  drawGaggia();
  u8g2.setFont( u8g2_font_crox1hb_tf);
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosBottom();
  u8g2.setFontDirection(0);
  u8g2.drawStr(0, 64, "espresso pid - v1.1");
  u8g2.sendBuffer();
  delay(5000);
  
  /*
  
  display.setTextColor(WHITE);
  display.clearDisplay();
  
  //version annotation
  Serial.println("espresso pid - v1.1");
  display.setCursor(0,0);
  display.println("espresso pid");
  display.setCursor(0,15);
  display.println("v1.1");
  display.setCursor(0,50);
  display.println("Matt FowlerFinn");
  display.display();
  display.setFont(&FreeSansBold9pt7b);
  display.setTextSize(1);
  delay(1000); 
  */
  
}

//////////////////////////////////////////////////////////////////
void sampleTemp() {
  sensors.requestTemperatures(); // Send the command to get temperatures
  float tempC = sensors.getTempC(insideThermometer);
  celsius = tempC;
  Input = celsius;
}

void calcPID() {
  //myPID.Compute();
  int scaler = ( WindowSize / pidMaxValue );
  int scaledOutput = (Output * scaler);
  
  if (millis() - windowStartTime > WindowSize)
  { 
    myPID.Compute();
    windowStartTime += WindowSize; //time to shift the Relay Window
  }
  if ((scaledOutput > millis() - windowStartTime) && (celsius < Setpoint)) {
    digitalWrite(SSRPin, HIGH);
    Serial.print("ON , ");
  }
  else {
    Serial.print("OFF, ");
    digitalWrite(SSRPin, LOW);
  }
}
  
void refreshDisplay() {
  u8g2.clearBuffer();
  u8g2.setFont( u8g2_font_crox3hb_tf);
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);
  u8g2.setCursor(0, 0);
  if(tempReady) {
    u8g2.setFont( u8g2_font_crox5hb_tf);
    u8g2.print("Ready!");
  }
  else {
    u8g2.setFont( u8g2_font_crox3hb_tf);
    u8g2.print("...please wait");
  }
  u8g2.setFontPosBottom();
  u8g2.setCursor(0, 64);
  u8g2.setFont( u8g2_font_crox5hb_tf);
  u8g2.print(celsius,1);
  u8g2.print("c ");
  u8g2.setFont( u8g2_font_crox1h_tf);
  u8g2.print("/ ");
  u8g2.print(Setpoint,0);
 

  
  u8g2.sendBuffer();
  /*
  display.setFont(&FreeSans12pt7b);
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.clearDisplay();
  display.setCursor(0,18);
  display.print(celsius,1);
  display.println("c");
  display.display();
  */

  Serial.print(celsius);
  Serial.print("C, ");
}

void loop(){
    /*  // picture loop  
    u8g2.firstPage();  
    do {
      refreshDisplay();
    } while( u8g2.nextPage() );*/
    
    sampleTemp();
    watchDog();
    adaptTune();
    calcPID();
    statusLight();
    refreshDisplay();
    Serial.println();
    delay (500);
    }

void watchDog() {
  if (celsius > (Setpoint+(toleranceWindow*2)))
  {  //TURN OFF PID IF OVER SETPOINT
    myPID.SetMode(MANUAL);
    Output = 0;
    Serial.println("OVERTEMP!!");
    delay(10000);
  }
}

void printAddress(DeviceAddress deviceAddress)
{
  for (uint8_t i = 0; i < 8; i++)
  {
    if (deviceAddress[i] < 16) Serial.print("0");
    Serial.print(deviceAddress[i], HEX);
  }
}

void statusLight() {
    //LED indicator
  if( (abs(Setpoint - celsius)) < toleranceWindow ) { 
      tempReady = true;
      //digitalWrite(LED_BUILTIN, LOW);
      Serial.print("READY TO BREW, ");
    }
    else { //NOT READY
      tempReady = false;
      //digitalWrite(LED_BUILTIN, HIGH);
      Serial.print("TEMP NOT CLOSE ENOUGH, ");
    }
}

void adaptTune() {
  if (celsius < 85) {
    myPID.SetTunings(aggKp, aggKi, aggKd);
  }
  else {
    myPID.SetTunings(Kp, Ki, Kd);
  }
  
  if (celsius > (Setpoint))
  {  //TURN OFF PID IF OVER SETPOINT
    myPID.SetMode(MANUAL);
    Output = 0;
  }
  else
  {
    myPID.SetMode(AUTOMATIC); 
  }
}
